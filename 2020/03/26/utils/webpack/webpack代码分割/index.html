<!DOCTYPE html>
<html>
<meta  lang="zh-CN" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <link rel="icon" href="/images/me.jpg">
  <title>我的博客</title>
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js" as="script">
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
  
<meta name="generator" content="Hexo 5.0.2"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/images/me.jpg">
      
      <span class="navbar-logo-dsc">我的博客</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">首页 </a>
    
    <a href="/archives" class="navbar-menu-item">归档 </a>
    
    <a href="/tags" class="navbar-menu-item">标签 </a>
    
    <a href="/categories" class="navbar-menu-item">分类 </a>
    
    <a href="/about" class="navbar-menu-item">关于 </a>
    
    <a href="/links" class="navbar-menu-item">友链 </a>
    
    <a class="navbar-menu-item" id="dark"><i class="iconfont icon-weather"></i></a>
  </div>
</nav>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      webpack代码分割
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2020-03-26T00:00:00.000Z" style="display: flex; align-items: center;">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2020-03-26</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/webpack/" class="post-meta-link">webpack</a>
    
    
    
    <span class="dot"></span>
    <span>1.7k 字</span>
    
  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/工具/" class="post-meta-link">工具</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>代码分割是 webpack 一个很大的亮点，它允许我们将代码拆分进不同的 bundle 中，然后按需加载或者并行加载。</p>
<p>通常有 3 中方式进行拆分：</p>
<ul>
<li>通过配置入口文件</li>
<li>通过<code>splitChunksPlugin</code>插件</li>
<li>通过<code>import</code>动态导入</li>
</ul>
<h5 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h5><p>通过指定不同入口文件来进行代码分割，这是最简单直接的代码分割的方式，不过这个。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    entry: &#123;<br>        one: <span class="hljs-string">&#x27;./src/one.js&#x27;</span>,<br>        two: <span class="hljs-string">&#x27;./src/two.js&#x27;</span><br>    &#125;,<br>    output: &#123;<br>        filename: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,<br>        path: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre>

<p>打包结果如下</p>
<pre class="highlight"><code class="hljs plain">            Asset     Size   Chunks             Chunk Names<br>one.bundle.js  550 KiB  one  [emitted]  one<br>  two.bundle.js  550 KiB    two  [emitted]  two<br>Entrypoint two &#x3D; two.bundle.js<br>Entrypoint one &#x3D; one.bundle.js<br></code></pre>

<p>不过这个方式有两个痛点：</p>
<ul>
<li>如果两个入口文件都依赖同一个模块，那么这个模块会被分别打包进两个 bundle 中，代码重复。</li>
<li>它不够灵活，不能用于与核心应用程序逻辑动态分割代码。</li>
</ul>
<p>阻止重复：</p>
<p>加入两个都依赖<code>loadsh</code>库，我们可以如下配置</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    entry: &#123;<br>        one: &#123;<br>            <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/one.js&#x27;</span>,<br>            dependOn: <span class="hljs-string">&#x27;shared&#x27;</span><br>        &#125;,<br>        two: &#123;<br>            <span class="hljs-keyword">import</span>: <span class="hljs-string">&#x27;./src/two.js&#x27;</span>,<br>            dependOn: <span class="hljs-string">&#x27;shared&#x27;</span><br>        &#125;,<br>        shared: <span class="hljs-string">&#x27;loadsh&#x27;</span><br>    &#125;,<br>    output: &#123;<br>        filename: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>,<br>        path: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre>

<h5 id="splitChunksPlugin"><a href="#splitChunksPlugin" class="headerlink" title="splitChunksPlugin"></a>splitChunksPlugin</h5><p>在 webpack4 之前是使用 CommonsChunkPlugin 来进行代码分割，在 webpack4 以后 CommonsChunkPlugin 被移除，推荐使用 splitChunksPlugin，它被 webapck 内置，在 optimization 配置项中配置。</p>
<p>在生产环境下，默认开启，默认配置如下：</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>    optimization: &#123;<br>        splitChunks: &#123;<br>            chunks: <span class="hljs-string">&#x27;async&#x27;</span>,<br>            minSize: <span class="hljs-number">20000</span>,<br>            minRemainingSize: <span class="hljs-number">0</span>,<br>            maxSize: <span class="hljs-number">0</span>,<br>            minChunks: <span class="hljs-number">1</span>,<br>            maxAsyncRequests: <span class="hljs-number">30</span>,<br>            maxInitialRequests: <span class="hljs-number">30</span>,<br>            automaticNameDelimiter: <span class="hljs-string">&#x27;~&#x27;</span>,<br>            enforceSizeThreshold: <span class="hljs-number">50000</span>,<br>            cacheGroups: &#123;<br>                defaultVendors: &#123;<br>                    test: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>                    priority: <span class="hljs-number">-10</span><br>                &#125;,<br>                <span class="hljs-keyword">default</span>: &#123;<br>                    minChunks: <span class="hljs-number">2</span>,<br>                    priority: <span class="hljs-number">-20</span>,<br>                    reuseExistingChunk: <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre>

<ul>
<li>chunks</li>
</ul>
<p>可选值为<code>async | initial | all</code>或者一个函数<code>function(chunk)</code></p>
<p>来指定哪个 chunk 将被进行抽离。<br><code>async</code>表示异步加载的模块，例如<code>import(xxx)</code>。<br><code>initial</code>表示初始化加载的模块，<code>import xx from &#39;xx&#39;</code>。<br><code>all</code>表示所有模块，也就是以上两种都包含。</p>
<p>如果是函数，函数的返回值表示是否包含每个块</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>    optimization: &#123;<br>        splitChunks: &#123;<br>            chunks(chunk) &#123;<br>                <span class="hljs-comment">// exclude `my-excluded-chunk`</span><br>                <span class="hljs-keyword">return</span> chunk.name !== <span class="hljs-string">&#x27;my-excluded-chunk&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre>

<p><em>可以结合<code>HtmlWebpackPlugin</code>插件使用这个选项，它默认会插入所有的 bundles</em></p>
<ul>
<li>maxAsyncRequests</li>
</ul>
<p>默认值：30<br>指定按需加载时最大的并行请求数</p>
<ul>
<li>maxInitialRequests</li>
</ul>
<p>默认值：30<br>每个入口点最大初始并行加载数</p>
<ul>
<li>minChunks</li>
</ul>
<p>默认值：1<br>chunks 被分割前至少被多少个模块依赖</p>
<ul>
<li>minSize</li>
</ul>
<p>默认值：20000<br>chunks 被分割前至少尺寸的大小（单位字节）</p>
<ul>
<li>automaticNameDelimiter</li>
</ul>
<p>默认值：~<br>指定生成名称的分隔符，例如<code>vendors~main.js</code>。</p>
<ul>
<li>minRemainingSize(webpack5)</li>
</ul>
<p>默认值：0<br>用来避免生成的 0 大小的 chunks，确保拆分后保留的块的最小大小高于限制。</p>
<ul>
<li>maxSize</li>
</ul>
<p>默认值：0<br>告诉 webpack 尝试将大于 maxSize 字节的块拆分为较小的部分，在 minSize 范围内。</p>
<p><strong>缓存组<code>cacheGroup</code></strong><br>上面的配置项都可以在缓存组中覆盖。<br>定义 chunk 属于哪个缓存组，默认使用键名作为缓存组的名称，可以通过<code>name</code>指定</p>
<ul>
<li>priority</li>
</ul>
<p>默认值：0<br>控制缓存组的优先级，值越大，优先级越高，可以是负数</p>
<ul>
<li>test</li>
</ul>
<p>控制当下缓存组匹配的 chunks，如果不指定，默认匹配所有 chunks</p>
<ul>
<li>filename</li>
</ul>
<p>当 chunk 为同加载模块时，才允许覆盖文件名。</p>
<ul>
<li>enforce</li>
</ul>
<p>默认值：false<br>告诉 webpack 忽略<code>splitChunks.minSize, splitChunks.minChunks, splitChunks.maxAsyncRequests and splitChunks.maxInitialRequests</code> 选项，并且总是为当前缓存组创建 chunks。</p>
<ul>
<li>reuseExistingChunk</li>
</ul>
<p>如果当前 chunk 包含的模块已经从 main bundle 中分离除去，它将会被复用，而不是生成一个新的 chunk。</p>
<h5 id="import-动态分割"><a href="#import-动态分割" class="headerlink" title="import 动态分割"></a>import 动态分割</h5><p>webpack 将<code>import()</code>作为分割点。意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。import 方法依赖于 Promise，如果需要在低版本浏览器使用，需要进行 polyfill</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">//a.js</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//doSomething</span><br>&#125;)<br></code></pre>

<p>import 规范不允许控制模块的名称或其他属性，因为 “chunks” 只是 webpack 中的一个概念，但是我们可以通过注释接收一些特殊的参数，而无须破坏规定。</p>
<ul>
<li><p>webpackChunkName：手动指定模块的名称</p>
</li>
<li><p>webpackMode：指定 webpack 以什么模式解析动态导入</p>
<ul>
<li>lazy：默认值，为每个 import()导入的模块生成一个可延迟加载的 chunk</li>
<li>lazy-once：生成 N 个可以延迟加载的 chunk，这个模式只能用于部分动态语句中有意义，比如 import(<code>./util/$&#123;tool&#125;.js</code>)，webpack 会将 util 下的每个 js 文件分别打包成一个单独的 chunk。</li>
<li>eager：这种模式不会生成额外的 chunk，所有模块都被当前 chunk 引入，不会有额外的网络请求。和静态导入相对比，在调用模块之前，该模块不会被执行。（静态导入第一回执行模块代码，ES Module 属于静态导入，commonjs 的 require 属于动态导入）</li>
<li>weak：尝试加载模块，如果该模块函数已经以其他方式加载（即，另一个 chunk 导入过此模块，或包含模块的脚本被加载）。仍然会返回 Promise，但是只有在客户端上已经有该 chunk 时才成功解析。如果该模块不可用，Promise 将会是 rejected 状态，并且网络请求永远不会执行。当需要的 chunks 始终在（嵌入在页面中的）初始请求中手动提供，而不是在应用程序导航在最初没有提供的模块导入的情况触发，这对于通用渲染（SSR）是非常有用的。（这个还不没使用过）</li>
</ul>
</li>
</ul>
<p>例子</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">//index.js</span><br><span class="hljs-keyword">let</span> util = <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">`./util/<span class="hljs-subst">$&#123;util&#125;</span>.js`</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;&#125;)<br><br><span class="hljs-comment">//util/a.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;add&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//util/b.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre>

<p>打包后目录如下</p>
<p><img src="/images/util/webpack/webpack%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/1.png" alt="打包结果" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/images/util/webpack/webpack%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2/1.png" class="lozad post-image"></p>
<p>我们可以看到，除了生成一个主 bundle（index.js），还生成了 1.js 和 2.js，分别对应 a.js 和 b.js 的 chunk。</p>
<p><strong>注意事项</strong></p>
<ul>
<li><p>import()不支持完全动态语句，例如 import(util)，因为 webpack 至少需要一些文件的路径信息，而 util 可能是任何一个路径，webpack 不可能将所有模块都打包出来一个 chunk。</p>
</li>
<li><p>一般我们使用 import()动态导入的模块，就不要再在其他模块静态引入此模块了，因为 webpack 分割 chunk 时，模块会被打包进静态导入它的 chunk 中，这样会造成无法分割 chunk 或者代码重复打包。</p>
</li>
</ul>

  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/2020/04/12/utils/webpack/webpack三种hash/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">上一篇</div>
        
        <div class="nav-title">hash,chunkhash,contenthash </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/2020/03/17/other/base64/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">base64编码 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#entry"><span class="toc-text">entry</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#splitChunksPlugin"><span class="toc-text">splitChunksPlugin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#import-%E5%8A%A8%E6%80%81%E5%88%86%E5%89%B2"><span class="toc-text">import 动态分割</span></a></li></ol>
</div></main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/images/avatar.jpg" class="author-img">

<p class="author-name">Chenzheng Ling</p>
<p class="author-description">Front End Developer</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>50</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>10</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>6</span>
    <span>标签</span>
  </a>
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#entry"><span class="toc-text">entry</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#splitChunksPlugin"><span class="toc-text">splitChunksPlugin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#import-%E5%8A%A8%E6%80%81%E5%88%86%E5%89%B2"><span class="toc-text">import 动态分割</span></a></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/css">
        <div class="categories-list-item">
          css
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/es">
        <div class="categories-list-item">
          es
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/http">
        <div class="categories-list-item">
          http
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/markdown">
        <div class="categories-list-item">
          markdown
          <span class="categories-list-item-badge">5</span>
        </div>
      </a>
    
      <a href="/categories/其他">
        <div class="categories-list-item">
          其他
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/typescript">
        <div class="categories-list-item">
          typescript
          <span class="categories-list-item-badge">9</span>
        </div>
      </a>
    
      <a href="/categories/vue">
        <div class="categories-list-item">
          vue
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/web">
        <div class="categories-list-item">
          web
          <span class="categories-list-item-badge">6</span>
        </div>
      </a>
    
      <a href="/categories/babel">
        <div class="categories-list-item">
          babel
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/webpack">
        <div class="categories-list-item">
          webpack
          <span class="categories-list-item-badge">6</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="\tags\工具" title="工具"><div class="tags-list-item">工具</div></a>
    
    <a href="\tags\编程语言" title="编程语言"><div class="tags-list-item">编程语言</div></a>
    
    <a href="\tags\js基础" title="js基础"><div class="tags-list-item">js基础</div></a>
    
    <a href="\tags\解决方案" title="解决方案"><div class="tags-list-item">解决方案</div></a>
    
    <a href="\tags\网络" title="网络"><div class="tags-list-item">网络</div></a>
    
    <a href="\tags\框架" title="框架"><div class="tags-list-item">框架</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">
  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#entry"><span class="toc-text">entry</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#splitChunksPlugin"><span class="toc-text">splitChunksPlugin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#import-%E5%8A%A8%E6%80%81%E5%88%86%E5%89%B2"><span class="toc-text">import 动态分割</span></a></li></ol>
  </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-10</div>
        <a href="/2021/03/10/typescript/typescript模块与命名空间/"><div class="recent-posts-item-content">typescript模块与命名空间</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-10</div>
        <a href="/2021/03/10/utils/webpack/webpack打包优化之noParse/"><div class="recent-posts-item-content">webpack打包之noParse优化</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-10</div>
        <a href="/2021/03/10/typescript/typescript高级类型/"><div class="recent-posts-item-content">typescript高级类型</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-03-10</div>
        <a href="/2021/03/10/typescript/typescript类型推论/"><div class="recent-posts-item-content">typescript类型推论</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div class="copyright">
      <div>
        <span id="copyYear">Copyright ©
          
          2020 -
          
          2021
        </span>
        <a href="/" class="footer-link">我的博客 </a>
      </div>
    </div>

    
    <div class="footer-dsc">
      
      
      Powered by
      <a href="https://hexo.io/" class="footer-link" target="_blank" rel="nofollow noopener noreferrer">&nbsp;Hexo </a>
      
      
      <span>&nbsp;|&nbsp;</span>
      
      
      
      Theme -
      <a href="https://github.com/theme-kaze" class="footer-link" target="_blank"
        rel="nofollow noopener noreferrer">&nbsp;Kaze</a>
      
    </div>
    
    
    
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton" >
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton">
  <i class="iconfont icon-expand button-icon"></i>
</a>

  
  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('data-fslightbox', 'gallery');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('style', 'width: 100%; display: flex; justify-content: center;');
      img[i].parentElement.insertBefore(wrapper, img[i]);
      wrapper.appendChild(img[i]);
    }
    refreshFsLightbox();
  }
</script>
<script>loadScript("//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  

  
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
  
</body>

</html>