<!DOCTYPE html>
<html>
<meta  lang="zh-CN" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <link rel="icon" href="/images/me.jpg">
  <title>我的博客</title>
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js" as="script">
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
  
<meta name="generator" content="Hexo 5.0.2"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/images/me.jpg">
      
      <span class="navbar-logo-dsc">我的博客</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">首页 </a>
    
    <a href="/archives" class="navbar-menu-item">归档 </a>
    
    <a href="/tags" class="navbar-menu-item">标签 </a>
    
    <a href="/categories" class="navbar-menu-item">分类 </a>
    
    <a href="/about" class="navbar-menu-item">关于 </a>
    
    <a href="/links" class="navbar-menu-item">友链 </a>
    
    <a class="navbar-menu-item" id="dark"><i class="iconfont icon-weather"></i></a>
  </div>
</nav>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      typescript高级类型
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2021-01-09T02:56:10.032Z" style="display: flex; align-items: center;">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2021-01-09</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/typescript/" class="post-meta-link">typescript</a>
    
    
    
    <span class="dot"></span>
    <span>2.4k 字</span>
    
  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/编程语言/" class="post-meta-link">编程语言</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h5 id="交叉类型-Intersection-Types"><a href="#交叉类型-Intersection-Types" class="headerlink" title="交叉类型(Intersection Types)"></a>交叉类型(Intersection Types)</h5><p>交叉类型是将多个类型合并为一个类型，使用<code>&amp;</code>操作符。</p>
<p>例如：</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>    a: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>    b: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-comment">//C类型既有a属性也有b属性</span><br><span class="hljs-keyword">type</span> C = A &amp; B<br></code></pre>

<p>大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extend</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">first: T, second: U</span>): <span class="hljs-title">T</span> &amp; <span class="hljs-title">U</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> first) &#123;<br>        ;(&lt;<span class="hljs-built_in">any</span>&gt;result)[id] = (&lt;<span class="hljs-built_in">any</span>&gt;first)[id]<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> second) &#123;<br>        <span class="hljs-keyword">if</span> (!result.hasOwnProperty(id)) &#123;<br>            ;(&lt;<span class="hljs-built_in">any</span>&gt;result)[id] = (&lt;<span class="hljs-built_in">any</span>&gt;second)[id]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">class</span> Person &#123;<br>    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">interface</span> Loggable &#123;<br>    log(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">class</span> ConsoleLogger <span class="hljs-keyword">implements</span> Loggable &#123;<br>    log() &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> jim = extend(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Jim&#x27;</span>), <span class="hljs-keyword">new</span> ConsoleLogger())<br><span class="hljs-keyword">var</span> n = jim.name<br>jim.log()<br></code></pre>

<h5 id="联合类型-Union-Types"><a href="#联合类型-Union-Types" class="headerlink" title="联合类型(Union Types)"></a>联合类型(Union Types)</h5><p>联合类型表示几种类型之一，使用<code>|</code>操作符。</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-comment">//如下Customer既可以是字符类型，也可以是数值类型</span><br><span class="hljs-keyword">type</span> Customer = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span><br><span class="hljs-keyword">let</span> c: Customer<br>c = <span class="hljs-number">123</span><br>c = <span class="hljs-string">&#x27;abc&#x27;</span><br></code></pre>

<p><strong>访问联合类型的属性</strong></p>
<p>如果联合类型有属性，我们只能访问所有类型中的共同属性</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>    name: <span class="hljs-built_in">string</span><br>    say(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>    age: <span class="hljs-built_in">number</span><br>    say(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">type</span> C = A | B<br><span class="hljs-keyword">let</span> o: C<br>o.say()<br>o.name <span class="hljs-comment">//error:类型C上不存在name属性</span><br>o.age <span class="hljs-comment">//error:类型C上不存在age属性</span><br></code></pre>

<p>如果需要访问联合类型上不是共同的属性，需要通过类型断言来访问。</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>    name: <span class="hljs-built_in">string</span><br>    say(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>    age: <span class="hljs-built_in">number</span><br>    say(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">type</span> C = A | B<br><span class="hljs-keyword">let</span> o: C<br><br><span class="hljs-keyword">let</span> n = (o <span class="hljs-keyword">as</span> A).name<br><span class="hljs-keyword">let</span> m = (&lt;A&gt;o).name<br></code></pre>

<p><strong>自定义类型保护</strong></p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>    name: <span class="hljs-built_in">string</span><br>    say(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>    age: <span class="hljs-built_in">number</span><br>    say(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">type</span> C = A | B<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">o: C</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> ((o <span class="hljs-keyword">as</span> A).name) &#123;<br>        <span class="hljs-built_in">console</span>.log((o <span class="hljs-keyword">as</span> A).name)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log((o <span class="hljs-keyword">as</span> B).age)<br>    &#125;<br>&#125;<br></code></pre>

<p>在上面的例子中，我们多次使用了类型断言，比较麻烦。如果我们希望一旦检查过类型，后面的分支就可以清除地知道数据的类型？</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>    name: <span class="hljs-built_in">string</span><br>    say(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>    age: <span class="hljs-built_in">number</span><br>    say(): <span class="hljs-built_in">void</span><br>&#125;<br><span class="hljs-keyword">type</span> C = A | B<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isA</span>(<span class="hljs-params">obj: A | B</span>): <span class="hljs-title">obj</span> <span class="hljs-title">is</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (obj <span class="hljs-keyword">as</span> A).name !== <span class="hljs-literal">undefined</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">o: C</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (isA(o)) &#123;<br>        <span class="hljs-built_in">console</span>.log(o.name)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(o.age)<br>    &#125;<br>&#125;<br></code></pre>

<p>在这个例子里，<code>obj is A</code>就是类型谓词。 谓词为<code>parameterName is Type</code> 这种形式，<code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。<br><em>typescript 不仅知道 if 里是 A 类型，它还知道 else 里面一定不是 A 类型</em></p>
<p><strong><code>typeof</code>类型保护</strong></p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">o: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">o</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">&#x27;number&#x27;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunction</span>(<span class="hljs-params">o: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">o</span> <span class="hljs-title">is</span> <span class="hljs-title">Function</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">&#x27;function&#x27;</span><br>&#125;<br></code></pre>

<p><strong>instanceof 类型保护</strong></p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDate</span>(<span class="hljs-params">o: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">o</span> <span class="hljs-title">is</span> <span class="hljs-title">Date</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> o <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span><br>&#125;<br></code></pre>

<p><strong>类型别名</strong></p>
<p>我们可以使用<code>type</code>关键字给类型起一个新名字，类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">type</span> Name = <span class="hljs-built_in">string</span><br><span class="hljs-keyword">type</span> Test = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span><br><span class="hljs-keyword">type</span> Check = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span><br></code></pre>

<p>类型别名使用泛型</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">type</span> Tree&lt;T&gt; = &#123;<br>    value: T<br>    left: Tree&lt;T&gt;<br>    right: Tree&lt;T&gt;<br>&#125;<br></code></pre>

<p><code>interface</code>(接口)与<code>type</code>(类型别名)的区别</p>
<ol>
<li>接口会创建一个新的类型，类型别名不会创建新的类型</li>
<li>类型别名不能被 extends 和 implements(自己也不能 extends 和 implements 其它类型)</li>
</ol>
<h5 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h5><pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">type</span> Names = <span class="hljs-string">&#x27;Tom&#x27;</span> | <span class="hljs-string">&#x27;Jack&#x27;</span> | <span class="hljs-string">&#x27;Jhon&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkName</span>(<span class="hljs-params">name: Names</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;Tom&#x27;</span>) &#123;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;Jack&#x27;</span>) &#123;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;Jhon&#x27;</span>) &#123;<br>    &#125;<br>&#125;<br></code></pre>

<h5 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h5><pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">type</span> Num = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">6</span><br></code></pre>

<h5 id="可辨识联合类型"><a href="#可辨识联合类型" class="headerlink" title="可辨识联合类型"></a>可辨识联合类型</h5><p>个人觉得可辨识联合类型就是通过某一个可辨识的特征，来确定具体是哪一种类型。</p>
<p>打个比方，A，B，C 三个人，A 叫张三，B 叫李四，C 也叫李四，那我们我们怎么来区分它们，名字肯定不行，首先必须找个他们共同拥有的属性，而且这个属性值不同。由此我们想到使用省份证号可以。</p>
<p>typescript 基于 javascript 模式，如果满足以下三个要素，则会自动辨别类型(收窄类型)。</p>
<ul>
<li>具有普通的单例类型属性— 可辨识的特征</li>
<li>一个类型别名包含了那些类型的联合— 联合</li>
<li>此属性上的类型保护</li>
</ul>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>    id: <span class="hljs-string">&#x27;1&#x27;</span><br>    name: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>    id: <span class="hljs-string">&#x27;2&#x27;</span><br>    age: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">interface</span> C &#123;<br>    id: <span class="hljs-string">&#x27;3&#x27;</span><br>    height: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">type</span> DU = A | B | C<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">person: DU</span>) </span>&#123;<br>    <span class="hljs-keyword">switch</span> (person.id) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>            <span class="hljs-comment">//类型辨识为A</span><br>            person.name<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>            <span class="hljs-comment">//类型辨识为B</span><br>            person.age<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:<br>            <span class="hljs-comment">//类型辨识为C</span><br>            person.height<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br></code></pre>

<p><strong>完整性检查</strong></p>
<p>上面的例子中我们可以看到，如果某天你的同事在有加了一个类型 D，代码编程输入下。</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> A &#123;<br>    id: <span class="hljs-string">&#x27;1&#x27;</span><br>    name: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">interface</span> B &#123;<br>    id: <span class="hljs-string">&#x27;2&#x27;</span><br>    age: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">interface</span> C &#123;<br>    id: <span class="hljs-string">&#x27;3&#x27;</span><br>    height: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">interface</span> D &#123;<br>    id: <span class="hljs-string">&#x27;4&#x27;</span><br>&#125;<br><span class="hljs-keyword">type</span> DU = A | B | C | D<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">person: DU</span>) </span>&#123;<br>    <span class="hljs-keyword">switch</span> (person.id) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>            <span class="hljs-comment">//类型辨识为A</span><br>            person.name<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>            <span class="hljs-comment">//类型辨识为B</span><br>            person.age<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:<br>            <span class="hljs-comment">//类型辨识为C</span><br>            person.height<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br></code></pre>

<p>在<code>test</code>函数里并没有 D 类型的处理逻辑，这个时候编译器并不会报错，可以通过编译，因为它可以走默认值。但是，如果我们必须要对每种类型处理，即在可辨识联合的变化时，我们想让编译器可以通知我们。</p>
<p><strong>使用<code>never</code>来检查完整性</strong></p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">person: DU</span>) </span>&#123;<br>    <span class="hljs-keyword">switch</span> (person.id) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>            <span class="hljs-comment">//类型辨识为A</span><br>            person.name<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>            <span class="hljs-comment">//类型辨识为B</span><br>            person.age<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:<br>            <span class="hljs-comment">//类型辨识为C</span><br>            person.height<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">//如果不能到达这个分支，则可以通过编译，如果达到了则报错</span><br>            <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">never</span> = person<br>            <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br></code></pre>

<h5 id="态this类型"><a href="#态this类型" class="headerlink" title="态this类型"></a>态<code>this</code>类型</h5><p>多态的 this 类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded 多态性。 它能很容易的表现连贯接口间的继承。</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">class</span> BasicCalculator &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">protected</span> value: <span class="hljs-built_in">number</span> = 0</span>) &#123;&#125;<br>    <span class="hljs-keyword">public</span> currentValue(): <span class="hljs-built_in">number</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value<br>    &#125;<br>    <span class="hljs-keyword">public</span> add(operand: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">this</span> &#123;<br>        <span class="hljs-built_in">this</span>.value += operand<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> multiply(operand: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">this</span> &#123;<br>        <span class="hljs-built_in">this</span>.value *= operand<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> ScientificCalculator <span class="hljs-keyword">extends</span> BasicCalculator &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-params">value = 0</span>) &#123;<br>        <span class="hljs-built_in">super</span>(value)<br>    &#125;<br>    <span class="hljs-keyword">public</span> sin() &#123;<br>        <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">this</span>.value)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>    &#125;<br>    <span class="hljs-comment">// ... other operations go here ...</span><br>&#125;<br><br><span class="hljs-keyword">let</span> v = <span class="hljs-keyword">new</span> ScientificCalculator(<span class="hljs-number">2</span>).multiply(<span class="hljs-number">5</span>).sin().add(<span class="hljs-number">1</span>).currentValue()<br></code></pre>

<p>如果没有 this 类型， ScientificCalculator 就不能够在继承 BasicCalculator 的同时还保持接口的连贯性。 multiply 将会返回 BasicCalculator，它并没有 sin 方法。 然而，使用 this 类型， multiply 会返回 this，在这里就是 ScientificCalculator。</p>
<h5 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h5><p>使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的 JavaScript 模式是从对象中选取属性的子集。</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProp</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">o: T, prop: K</span>): <span class="hljs-title">T</span>[<span class="hljs-title">K</span>] </span>&#123;<br>    <span class="hljs-keyword">return</span> o[prop]<br>&#125;<br></code></pre>

<p><strong><code>keyof</code>索引类型操作符</strong></p>
<p>语法：<code>keyof T</code></p>
<p>对于任何类型 <code>T</code>， <code>keyof T</code> 的结果为 <code>T</code> 上已知的公共属性名的联合。</p>
<p>例如</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> Person &#123;<br>    name: <span class="hljs-built_in">string</span><br>    age: <span class="hljs-built_in">number</span><br>&#125;<br><span class="hljs-keyword">let</span> personKeys: keyof Person <span class="hljs-comment">//personKeys为 &#x27;name&#x27; | &#x27;age&#x27;类型</span><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">type</span> personKeys = keyof Person<br></code></pre>

<p><strong>索引类型和字符串索引签名</strong></p>
<p><code>keyof</code>和 <code>T[K]</code>与字符串索引签名进行交互。 如果你有一个带有字符串索引签名的类型，那么 <code>keyof T</code>会是 <code>string</code>。 并且 <code>T[string]</code>为索引签名的类型：</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> Map&lt;T&gt; &#123;<br>    [key: <span class="hljs-built_in">string</span>]: T<br>&#125;<br><span class="hljs-keyword">let</span> keys: keyof <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">number</span>&gt; <span class="hljs-comment">// string</span><br><span class="hljs-keyword">let</span> value: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">number</span>&gt;[<span class="hljs-string">&#x27;foo&#x27;</span>] <span class="hljs-comment">// number</span><br></code></pre>

<h5 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h5><p>typescript 提供一种从旧类型创造新类型的方式。</p>
<p>简单例子</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">type</span> Keys = <span class="hljs-string">&#x27;option1&#x27;</span> | <span class="hljs-string">&#x27;option2&#x27;</span><br><span class="hljs-keyword">type</span> Flags = &#123; [K <span class="hljs-keyword">in</span> Keys]: <span class="hljs-built_in">boolean</span> &#125;<br><br><span class="hljs-comment">//Flag -&gt; type Flag &#123;option1:boolean,options2:boolean&#125;</span><br></code></pre>

<p>它的语法与索引签名的语法类型，内部使用了 for .. in。 具有三个部分：</p>
<ol>
<li>类型变量 K，它会依次绑定到每个属性。</li>
<li>字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。</li>
<li>属性的结果类型。</li>
</ol>
<p>使用泛型的通用写法</p>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">interface</span> Person &#123;<br>    name: <span class="hljs-built_in">string</span><br>    age: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> MapPerson&lt;T&gt; = &#123;<br>    [P <span class="hljs-keyword">in</span> keyof T]?: T[P]<br>&#125;<br><br><span class="hljs-keyword">type</span> OptionalPerson = MapPerson&lt;Person&gt;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">person: OptionalPerson</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(person)<br>&#125;<br><span class="hljs-comment">//只传入name也是可以的，因为他们都是可选的</span><br>test(&#123; name: <span class="hljs-string">&#x27;abc&#x27;</span> &#125;)<br></code></pre>

<h5 id="预定义类型"><a href="#预定义类型" class="headerlink" title="预定义类型"></a>预定义类型</h5><ul>
<li><code>Exclude&lt;T, U&gt;</code> – 从 T 中剔除可以赋值给 U 的类型。</li>
<li><code>Extract&lt;T, U&gt;</code> – 提取 T 中可以赋值给 U 的类型。</li>
<li><code>NonNullable&lt;T&gt;</code> – 从 T 中剔除 null 和 undefined。</li>
<li><code>ReturnType&lt;T&gt;</code> – 获取函数返回值类型。</li>
<li><code>InstanceType&lt;T&gt;</code> – 获取构造函数类型的实例类型。</li>
</ul>
<pre class="highlight"><code class="hljs typescript"><span class="hljs-keyword">type</span> T00 = Exclude&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span> | <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span> | <span class="hljs-string">&#x27;f&#x27;</span>&gt; <span class="hljs-comment">// &quot;b&quot; | &quot;d&quot;</span><br><span class="hljs-keyword">type</span> T01 = Extract&lt;<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;b&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span> | <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;c&#x27;</span> | <span class="hljs-string">&#x27;f&#x27;</span>&gt; <span class="hljs-comment">// &quot;a&quot; | &quot;c&quot;</span><br><br><span class="hljs-keyword">type</span> T02 = Exclude&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>), <span class="hljs-built_in">Function</span>&gt; <span class="hljs-comment">// string | number</span><br><span class="hljs-keyword">type</span> T03 = Extract&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>), <span class="hljs-built_in">Function</span>&gt; <span class="hljs-comment">// () =&gt; void</span><br><br><span class="hljs-keyword">type</span> T04 = NonNullable&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>&gt; <span class="hljs-comment">// string | number</span><br><span class="hljs-keyword">type</span> T05 = NonNullable&lt;(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>) | <span class="hljs-built_in">string</span>[] | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>&gt; <span class="hljs-comment">// (() =&gt; string) | string[]</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123; a: <span class="hljs-number">1</span>, b: s &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> C &#123;<br>    x = <span class="hljs-number">0</span><br>    y = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">type</span> T10 = ReturnType&lt;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>&gt; <span class="hljs-comment">// string</span><br><span class="hljs-keyword">type</span> T11 = ReturnType&lt;<span class="hljs-function">(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>&gt; <span class="hljs-comment">// void</span><br><span class="hljs-keyword">type</span> T12 = ReturnType&lt;&lt;T&gt;<span class="hljs-function">() =&gt;</span> T&gt; <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-keyword">type</span> T13 = ReturnType&lt;&lt;T <span class="hljs-keyword">extends</span> U, U <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span>[]&gt;<span class="hljs-function">() =&gt;</span> T&gt; <span class="hljs-comment">// number[]</span><br><span class="hljs-keyword">type</span> T14 = ReturnType&lt;<span class="hljs-keyword">typeof</span> f1&gt; <span class="hljs-comment">// &#123; a: number, b: string &#125;</span><br><span class="hljs-keyword">type</span> T15 = ReturnType&lt;<span class="hljs-built_in">any</span>&gt; <span class="hljs-comment">// any</span><br><span class="hljs-keyword">type</span> T16 = ReturnType&lt;<span class="hljs-built_in">never</span>&gt; <span class="hljs-comment">// any</span><br><span class="hljs-keyword">type</span> T17 = ReturnType&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">type</span> T18 = ReturnType&lt;<span class="hljs-built_in">Function</span>&gt; <span class="hljs-comment">// Error</span><br><br><span class="hljs-keyword">type</span> T20 = InstanceType&lt;<span class="hljs-keyword">typeof</span> C&gt; <span class="hljs-comment">// C</span><br><span class="hljs-keyword">type</span> T21 = InstanceType&lt;<span class="hljs-built_in">any</span>&gt; <span class="hljs-comment">// any</span><br><span class="hljs-keyword">type</span> T22 = InstanceType&lt;<span class="hljs-built_in">never</span>&gt; <span class="hljs-comment">// any</span><br><span class="hljs-keyword">type</span> T23 = InstanceType&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">type</span> T24 = InstanceType&lt;<span class="hljs-built_in">Function</span>&gt; <span class="hljs-comment">// Error</span><br></code></pre>

  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/2021/01/09/typescript/typescript声明文件/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">上一篇</div>
        
        <div class="nav-title">typescript声明文件 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/2021/01/09/typescript/typescript类型推论/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">typescript类型推论 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B-Intersection-Types"><span class="toc-text">交叉类型(Intersection Types)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B-Union-Types"><span class="toc-text">联合类型(Union Types)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">字符串字面量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">数字字面量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BE%A8%E8%AF%86%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">可辨识联合类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%81this%E7%B1%BB%E5%9E%8B"><span class="toc-text">态this类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">映射类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">预定义类型</span></a></li></ol>
</div></main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/images/avatar.jpg" class="author-img">

<p class="author-name">Chenzheng Ling</p>
<p class="author-description">Front End Developer</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>48</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>10</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>6</span>
    <span>标签</span>
  </a>
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B-Intersection-Types"><span class="toc-text">交叉类型(Intersection Types)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B-Union-Types"><span class="toc-text">联合类型(Union Types)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">字符串字面量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">数字字面量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BE%A8%E8%AF%86%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">可辨识联合类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%81this%E7%B1%BB%E5%9E%8B"><span class="toc-text">态this类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">映射类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">预定义类型</span></a></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/css">
        <div class="categories-list-item">
          css
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/es">
        <div class="categories-list-item">
          es
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/http">
        <div class="categories-list-item">
          http
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/markdown">
        <div class="categories-list-item">
          markdown
          <span class="categories-list-item-badge">5</span>
        </div>
      </a>
    
      <a href="/categories/其他">
        <div class="categories-list-item">
          其他
          <span class="categories-list-item-badge">7</span>
        </div>
      </a>
    
      <a href="/categories/typescript">
        <div class="categories-list-item">
          typescript
          <span class="categories-list-item-badge">9</span>
        </div>
      </a>
    
      <a href="/categories/vue">
        <div class="categories-list-item">
          vue
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/web">
        <div class="categories-list-item">
          web
          <span class="categories-list-item-badge">6</span>
        </div>
      </a>
    
      <a href="/categories/babel">
        <div class="categories-list-item">
          babel
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/webpack">
        <div class="categories-list-item">
          webpack
          <span class="categories-list-item-badge">5</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="\tags\工具" title="工具"><div class="tags-list-item">工具</div></a>
    
    <a href="\tags\编程语言" title="编程语言"><div class="tags-list-item">编程语言</div></a>
    
    <a href="\tags\js基础" title="js基础"><div class="tags-list-item">js基础</div></a>
    
    <a href="\tags\解决方案" title="解决方案"><div class="tags-list-item">解决方案</div></a>
    
    <a href="\tags\网络" title="网络"><div class="tags-list-item">网络</div></a>
    
    <a href="\tags\框架" title="框架"><div class="tags-list-item">框架</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">
  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B-Intersection-Types"><span class="toc-text">交叉类型(Intersection Types)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B-Union-Types"><span class="toc-text">联合类型(Union Types)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">字符串字面量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">数字字面量类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BE%A8%E8%AF%86%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">可辨识联合类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%81this%E7%B1%BB%E5%9E%8B"><span class="toc-text">态this类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">映射类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-text">预定义类型</span></a></li></ol>
  </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-09</div>
        <a href="/2021/01/09/typescript/typescript模块与命名空间/"><div class="recent-posts-item-content">typescript模块与命名空间</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-09</div>
        <a href="/2021/01/09/typescript/typescript声明文件/"><div class="recent-posts-item-content">typescript声明文件</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-09</div>
        <a href="/2021/01/09/typescript/typescript高级类型/"><div class="recent-posts-item-content">typescript高级类型</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2021-01-09</div>
        <a href="/2021/01/09/typescript/typescript类型推论/"><div class="recent-posts-item-content">typescript类型推论</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div class="copyright">
      <div>
        <span id="copyYear">Copyright ©
          
          2020 -
          
          2021
        </span>
        <a href="/" class="footer-link">我的博客 </a>
      </div>
    </div>

    
    <div class="footer-dsc">
      
      
      Powered by
      <a href="https://hexo.io/" class="footer-link" target="_blank" rel="nofollow noopener noreferrer">&nbsp;Hexo </a>
      
      
      <span>&nbsp;|&nbsp;</span>
      
      
      
      Theme -
      <a href="https://github.com/theme-kaze" class="footer-link" target="_blank"
        rel="nofollow noopener noreferrer">&nbsp;Kaze</a>
      
    </div>
    
    
    
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton" >
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton">
  <i class="iconfont icon-expand button-icon"></i>
</a>

  
  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('data-fslightbox', 'gallery');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('style', 'width: 100%; display: flex; justify-content: center;');
      img[i].parentElement.insertBefore(wrapper, img[i]);
      wrapper.appendChild(img[i]);
    }
    refreshFsLightbox();
  }
</script>
<script>loadScript("//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  

  
  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>
  
</body>

</html>